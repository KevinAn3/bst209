------------------------------------------------------------------------

title: "01 - Data Visualization" author: "Renata Pr√¥a" date: "2023-07-19" output: html_document

# Introduction

Looking at the numbers and character strings that define a dataset is rarely useful. To convince yourself, print and stare at this data table:

```{r}
library(tidyverse)
cohort <- read_csv("./eicu_cohort_trees.csv")
head(cohort)
```

What do you learn from staring at this table? Let's focus on the Apache score, which already brings together a lot of information in this table. How quickly can you determine which patients have the highest Apache scores? Which have the smallest? What is their age? What is their gender? Did they actually die in the hospital? What is the mean Apache score? Is there a relationship between the Apache Score and age? How does it vary with gender? What is the age distribution of the cohort? For most human brains it is quite difficult to extract this information just from looking at the numbers. In contrast, the answer to all the questions above are readily available from examining this plot:

```{r}
library(ggthemes)

cohort <- cohort %>%
  mutate(age = as.integer(age)) %>%
  mutate(age = if_else(is.na(age), 91.5, age))

mean_apache_by_age <- aggregate (apachescore ~ age, data = cohort, FUN = mean)

ggplot() +
geom_point(data = cohort, aes(x = age, y = apachescore, color = gender, shape = actualhospitalmortality)) +
geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore, linetype = "Mean Apache Score")) +
  
scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality')+
scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                   labels = c("Female", "Male", "Unknown"), name = "Gender") +
scale_linetype_manual(values = "solid", name = "") +

xlab("Age") + 
ylab("Apache Score") +
ggtitle("Apache Score in the eICU demo data") +
theme_economist() +
theme(legend.title = element_text(size = 10, face = "bold"), 
      legend.text = element_text(size = 9),
      legend.spacing = unit(-0.1, "cm"),
      legend.key.size = unit(0.3, "cm"))
```

We are reminded of the saying "a picture is worth a thousand words". Data visualization provides a powerful way to communicate a data-driven finding. In some cases, the visualization is so convincing that no follow-up analysis is required. We also note that many widely used data analysis tools were initiated by discoveries made via exploratory data analysis (EDA). EDA is perhaps the most important part of data analysis, yet is often overlooked.

It is also important to note that mistakes, biases, systematic errors and other unexpected problems often lead to data that should be handled with care. Failure to discover these problems often leads to flawed analyses and false discoveries. As an example, consider that measurement devices sometimes fail and that most data analysis procedures are not designed to detect these. Yet, these data analysis procedures will still give you an answer. The fact that it can be hard or impossible to notice an error just from the reported results, makes data visualization particularly important.

Today we will learn the basics of the ggplot2 package - the software we will use to learn the basics of data visualization and exploratory data analysis. We will use the [demo version](https://doi.org/10.13026/4mxk-na84) of the [eICU Collaborative Research Database](https://eicu-crd.mit.edu/about/eicu/) that we used in the last workshop to learn the basics of ggplot2. As a recap, this is a publicly available dataset comprising deidentified physiological data collected from critically ill patients. Then we will cover world health and economics and infectious disease trends in the United States on an exercise notebook.

Note that there is much more to data visualization than what we cover here. More references include:

-   ER Tufte (1983) The visual display of quantitative information. Graphics Press.
-   ER Tufte (1990) Envisioning information. Graphics Press.
-   ER Tufte (1997) Visual explanations. Graphics Press.
-   A Gelman, C Pasarica, R Dodhia (2002) Let's practice what we preach: Turning tables into graphs. The American Statistician 56:121-130
-   NB Robbins (2004) Creating more effective graphs. Wiley
-   Rob Kabacoff (2018) [Data Visualization with R](https://rkabacoff.github.io/datavis/)

We will cover the basics of interactive graphics later in this course. If you want to check out interactive graphs now, below are some useful resources for learning more.

-   <https://shiny.rstudio.com/>
-   <https://d3js.org/>

## Some minimum data preparation

Although the visualization is often the first step in an EDA, before data preparation, which evolves in an interactive process with the EDA and visualization, to make this workshop simpler, we will apply minor changes in the data to begin with. We'll rename some columns for clarity and we will fix the age data (TO DO). In our database, the age information was imputed as character and not numerical data. Also, ages over 89 years are recorded as "\>89" to comply with US data privacy laws. For simplicity, we will assign an age of 91.5 years to these patients (this is the approximate average age of patients over 89 in the dataset).

```{r}

# Just for the sake of clarity, rename columns as in the last workshop
names(cohort)[names(cohort) == "unabridgedhosplos"] <- "length_of_stay"
names(cohort)[names(cohort) == "meanbp"] <- "mean_blood_pressure"
names(cohort)[names(cohort) == "wbc"] <- "white_cell_count"

# Handle the deidentified ages
cohort <- cohort %>%
  mutate(age = as.integer(age)) %>%
  mutate(age = if_else(is.na(age), 91.5, age))

```

## A first introduction to ggplot2

Now we are ready to learn how to create a the we showed part by part. We will be using the [`ggplot2`](http://ggplot2.org) package. We can load it, along with `dplyr`, as part of the tidyverse:

```{r, message=FALSE}
library(tidyverse)
```

One reason `ggplot2` is generally more intuitive for beginners is that it uses a *grammar of graphics*, the *gg* in `ggplot2`. This is analogous to the way learning grammar can help a beginner construct hundreds of different sentences by learning just a a handful of verbs, nouns and adjectives without having to memorize each specific sentence. Similarly, by learning a handful of `ggplot2` building blocks and its grammar, you will be able to create hundreds of different plots.

Another reason `ggplot2` makes it easier for beginners is that its default behavior is carefully chosen to satisfy the great majority of cases and are aesthetically pleasing. As a result, it is possible to create informative and elegant graphs with relatively simple and readable code.

One limitation is that ggplot is designed to work exclusively with data tables in which rows are observations and columns are variables. However, a substantial percentage of datasets that beginners work with are, or can be converted into, this format. An advantage of this approach is that assuming that our data follows this format simplifies the code and learning the grammar.

### The Cheat Sheet

To use `ggplot2` you will have to learn several functions and arguments. These are hard to memorize so we highly recommend you have the a [ggplot2 cheat sheet](https://www.rstudio.com/resources/cheatsheets/) handy.

### The components of a graph

The first step in learning `ggplot2` is to be able to break a graph apart into components. Let's break down this plot and introduce some of the `ggplot2` terminology. The three main components to note are:

1.  **Data**: The eICU demo data table is being summarized. We refer to this as the **data** component.
2.  **Geometry**: The plot above is a scatter plot. This is referred to as the **geometry** component. Other possible geometries are barplots, histograms, smooth densities, qqplots, and boxplots.
3.  **Aesthetic mapping**: The x-axis values are used to display the patients' age, the y-axis values are used to display the Apache score, shapes are being used to identify the patients that actually died in the hospital, and colors are used to show the gender. These are the **aesthetic mappings** component. How we define the mapping depends on what **geometry** we are using.

We also note that:

4.  The range of the x-axis and y-axis appears to be defined by the range of the data. We refer to this as the **scale** component.
5.  There are labels, a title, a legend, and we use the style of The Economist magazine for this particular plot.

We will now construct the plot piece by piece.

### Creating a blank slate `ggplot` object

The first step in creating a `ggplot2` graph is to define a `ggplot` object. We do this with the function `ggplot` which initializes the graph. If we read the help file for this function we see that the first argument is used to specify which data is associated with this object:

```{r ggplot-example-1, eval=FALSE}
ggplot(data = cohort)
```

We can also pipe the data. So this line of code is equivalent to the one above:

```{r ggplot-example-2}
cohort %>% ggplot()
```

What has happened above is that the object was created and because it was not assigned, it was automatically evaluated. But note that we can define an object, for example like this:

```{r}
p <- ggplot(data = cohort)
class(p)
```

To render the plot associated with this object we simply print the object `p`. The following two lines of code produce the same plot we see above:

```{r, eval=FALSE}
print(p)
p
```

In ggplot we create graphs by adding *layers*. Layers can define geometries, compute summary statistics, define what scales to use, or even change styles. To add layers, we use the the symbol `+`. In general a line of code will look like this:

> > DATA %\>% `ggplot()` + LAYER 1 + LAYER 2 + ... + LAYER N

Usually, the first added layer defines the geometry. We want to make a scatter plot. So what geometry do we use?

#### Geometry

Taking a quick look at the cheat sheet we see that the function used to create plots with this geometry is `geom_point`.

We will see that geometry function names follow this pattern: `geom` and the name of the geometry connected by an underscore. For `geom_point` to know what to do, we need to provide data and a mapping. We have already connected the object `p` with the `cohort` data table and if we add as a layer `geom_point` we will default to using this data. To find out what mappings are expected we read the **Aesthetics** section of the `geom_point` help file:

> Aesthetics
>
> geom_point understands the following aesthetics:
>
> x
>
> y
>
> alpha
>
> colour

and, as expected, we see that at least two arguments are required: `x` and `y`.

### `aes`

`aes` will be one of the functions that you will most use. The function connects data with what we see on the graph. We refer to this connection as the **aesthetic mappings**. The outcome of this function is often used as the argument of a geometry function. This example produces a scatter plot of total murders versus population in millions:

```{r, eval = FALSE}
cohort %>% ggplot() + 
            geom_point(aes(x = age, y = apachescore))
```

the first and second expected arguments as seen on the help page.

Also note that we can add a layer to the `p` object that was defined above as `p <- ggplot(data = cohort)`:

```{r}
p + geom_point(aes(age, apachescore))
```

layer. Also notice that we use the variable names from the object component: `age` and `apachescore`.

Keep in mind that the behavior of recognizing the variables from the data component is quite specific to `aes`. With most functions, if you try to access the values of `age` or `apachescore` outside of `aes` you receive an error.

#### Categories as colors

Note that we can change the color of the points using the `color` argument in the `geom_point` function. We can make all the points blue by adding the `color` argument, change their `size` and `shape`! You can check the code number for shapes [here](http://www.sthda.com/english/wiki/ggplot2-point-shapes).

```{r}
p + geom_point(aes(age, apachescore), color = "blue", size = 3, shape = 17)

```

This, of course, is not what we want. We want to assign color depending on the geographical region. A nice default behavior of `ggplot2` is that if we assign a categorical variable to color, it automatically assigns a different color to each category. It also adds a legend!

To map each point to a color, we need to use `aes` since this is a mapping. So we use the following code:

```{r}
p + geom_point(aes(age, apachescore, color = gender))
```

Here we see yet another useful default behavior: `ggplot2` has automatically added a legend that maps color to gender. Similarly, we can use the shape of the data points to indicate whether the patient died or no in the hospital.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality))
```

The default shapes are not very easy to distinguish visually in our plot. We can specify the shapes we want using `scale_shape_manual()`. (to do ref)

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality')
```

We also changed the label names so they look prettier. We can do the same with the color aspect using scale_color_manual(). Don't forget to always add a `+` when adding a new layer to your plot.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender")
```

#### Adding other layers

We want to a a line the represents the average Apache Score by age. To do that, we must first calculate the mean value of the Apache Score for each age value (once the values we gave are discrete), which we can achieve by using the function `aggregate`. This function allows us to get the summary statistics of the data by group. The statistics include mean, min, sum. max etc.

```{r}
mean_apache_by_age <- aggregate (apachescore ~ age, data = cohort, FUN = mean)
print(mean_apache_by_age)
```

Note that `apachescore ~ age` is a way in R to specify a formula for a statistical model, the `~` symbol is used to separate the dependent variable (apachescore) from the independent variable (age). In this case we need to specify the data and also the statistical function we want, in this case "mean". Another way to pass the arguments to the aggregate function would be:

```{r}
mean_apache_by_age <- aggregate (cohort$apachescore, by=list(cohort$age), FUN = mean)
print(mean_apache_by_age)
```

But the variables names got lost! So we need to fix it.

```{r}
mean_apache_by_age <- aggregate (cohort$apachescore, by=list(cohort$age), FUN = mean)
names(mean_apache_by_age)[names(mean_apache_by_age) == "Group.1"] <- "age"
names(mean_apache_by_age)[names(mean_apache_by_age) == "x"] <- "apachescore"
print(mean_apache_by_age)
```

So now that we have the mean values for the Apache score, by age lest plot it!

```{r}
ggplot(mean_apache_by_age) +
  geom_line(aes(x = age, y = apachescore))
```

That's not quite what we wanted. Why? Here we used the geometry `geom_line()` that draws a line across the data points of our dataset. But remember that we have discrete values for age, and also, the data is noisy and we don't have that many data points to actually get a smooth line as we wanted. A way around this is to use another geometry: `geom_smooth()`.

```{r}
ggplot(mean_apache_by_age) +
  geom_smooth(aes(x = age, y = apachescore))
```

Now it looks like what wanted! The `geom_smooth()` fits a trend line in a our data using local regression. By default it adds this dark grey shadowed area indicating the confidence interval (0.95 by default). You can play around and change the settings!

Now we just need to add this plot to our original plot:

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender") +
  geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore))
  
```

Note that we didn't have to create another `ggplot()` object, but we did have to specify in the new layer that we are using a different data.

### Labels and Titles

Now that we've got all the data, we can change labels and add a title we use the following functions: `xlab`, `ylab` and `ggtitle`.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender") +
  geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore)) + 
  xlab("Age") + 
  ylab("Apache Score") +
  ggtitle("Apache Score in the eICU demo data")
  
```

We are still missing a legend for the mean Apache Score trend line. We can do that by defining a `linetype` in the geometry and using `scale_linetype_manual()`.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender") +
  geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore, linetype = "Mean Apache Score")) + 
  scale_linetype_manual(values = "solid", name = "") +
  xlab("Age") + 
  ylab("Apache Score") +
  ggtitle("Apache Score in the eICU demo data")
  
```

### Styles and Adjusting

Finally we can add a theme style to our plot. We used the `theme_economist()` from the Economist magazine.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender") +
  geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore, linetype = "Mean Apache Score")) + 
  scale_linetype_manual(values = "solid", name = "") +
  xlab("Age") + 
  ylab("Apache Score") +
  ggtitle("Apache Score in the eICU demo data") +
  theme_economist()
  
```

Changing the theme bungled our legend, so we nee to adjust it. We do that by using the function `theme()` and setting the legend parameters.

```{r}
p + geom_point(aes(age, apachescore, color = gender, shape = actualhospitalmortality)) +
  scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality') +
  scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                     labels = c("Female", "Male", "Unknown"), name = "Gender") +
  geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore, linetype = "Mean Apache Score")) + 
  scale_linetype_manual(values = "solid", name = "") +
  xlab("Age") + 
  ylab("Apache Score") +
  ggtitle("Apache Score in the eICU demo data") +
  
  theme_economist() +
  theme(legend.title = element_text(size = 10, face = "bold"), 
        legend.text = element_text(size = 9),
        legend.spacing = unit(-0.1, "cm"),
        legend.key.size = unit(0.3, "cm"))
  
```

## Explore!

Now that we learned how to make a complete plot in R, you can explore trying to change the parameters, variables and geometries to visualize all the dataset. Is important to notice that a huge challenge in data visualization is to plot very high dimensional data. When we have many variables as in the eICU dataset, we will need to make a few different plots to actually be able to visualize all the data without performing major transformations and dimensionality reduction.

One solution is looking for the most representative variables of the dataset, as we did here. The Apache Score uses many of the other variables available in the dataset in its calculation, so in a way, it already summarizes big part of the data!

Here are some other interesting plots to visualize the eICU demo data.

## Looking at the Distribution of Variables

As we mentioned before, our dataset is one with many variables and it is normally not possible to visualize them all at once. In this case, it is part of the data inspection process to visualize all the variables individually.

One of the first things that we need to check is the distribution of the data. One of the most useful types of plots to check the distribution of a variable is the histogram. To make a histogram using ggplot2 we use geom_histogram() to specify that the geometry that we want is a histogram. We also need to specify the what is the variable that we want using the aes() function. In a histogram, normally the values of the variable of interest are on the x-axis and the y-axis reflects the frequency of the values.

#### Age

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = age))
```

Note that we don't need to specify in this case that y-axis will reflect the value counts, it is already implicit. I the case of continuous variables, to make a histogram, we need to 'bin' the values. We can regulate the bin size with the parameter 'binwidth'.

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = age), binwidth = 5, fill = "skyblue", color = "darkblue") +
labs(title = "Age Distribution", x = "Age", y = "Frequency")
```

Notice how we also changed the colors, title and labels. Let's make histograms for all the variables in the dataset.

#### Gender

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = gender)) +
labs(title = "Gender", x = "Age", y = "Frequency")
```

Notice that when we try plotting a histogram for gender, it raises an error. That is because `geom_histogram()` is designed to work with continuous numeric variables. If we want to check the distribution of categorical varibles, we can use `geom_bar()`.

```{r}
ggplot(data = cohort) +
geom_bar(aes(x = gender), fill = 'darkblue') +
labs(title = "Gender Distribution", x = "Gender", y = "Frequency")
```

#### Actual Hospital Mortality

```{r}
ggplot(data = cohort) +
geom_bar(aes(x = actualhospitalmortality
), fill = 'darkblue') +
labs(title = "Actual Hospital Mortality Proportion", x = "Outcome", y = "Frequency")
```

Hint: we can make one single figure containing those two plots by using the `grid.arrange()` function from the `gridExtra` package to make subplots.

```{r}
library(gridExtra)

p1 <- ggplot(data = cohort) +
      geom_bar(aes(x = gender), fill = 'darkblue') +
      labs(title = "Gender Distribution", x = "Gender", y =   "Frequency") +
      theme(plot.title = element_text(size = 11))

p2 <- ggplot(data = cohort) +
      geom_bar(aes(x = actualhospitalmortality), fill = 'darkblue') +
      labs(title = "Actual Hospital Mortality Proportion", x = "Outcome", y =   "Frequency") +
      theme(plot.title = element_text(size = 11))

grid.arrange(p1, p2, ncol = 2)
```

We adjusted the size of the title also so it fist the picture. Let's check the distribution of the other variables.

#### Admission Height

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = admissionheight), fill = "darkgreen") +
labs(title = "Admission Height Distribution", x = "Height", y = "Frequency")
```

We can notice two import things from rendering this plot. First, is the Warning message that tells us the 8 rows were found containing non-finite values. Second, are the outlier values that we easily spot in the plot. We wouldn't be able to see those so fast just by looking at the tabular data. Hence the importance of checking the distribution of the data.

It is important to differentiate what are actual real outliers on the distribution (values that are distant from the main distribution but are real measurements from a patient) from what are incorrectly entered values or missing data. Visually we see three outliers: one at 0, another one around 70 and a third one at 300. We know from logic that no patient has zero height and that tallest man alive as of today has around 250cm. Therefore, those two values are miss-entered data, and need be corrected. The other one though, despite being an outlier is perfectly reasonable once it could be the data from a child or a subject with dwarfism, for example.

```{r}
selected_rows <- subset(cohort, admissionheight >= 50 & admissionheight <= 100)
print(selected_rows)
```

A way to deal incorrectly inputted or missing data is by replacing those with the mean or median. The correct solution for dealing with missing data depends on on many factors, like the type of modeling you will be using and the amount of data missing. Here, we are not taking in consideration any modelling strategy, so naively we will replace the missing data with the median. Obs: a way to improve to this for example would be to substitute the height not by the total median, but buy the median height of the patients' gender.

```{r}
selected_rows <- subset(cohort, admissionheight >= 250 | admissionheight <= 5)
print(selected_rows)
```

Looking at the data we can imagine in the second case what happened is the the measurement is in meters instead of centimeters. Let's correct this.

```{r}
cohort$admissionheight[cohort$admissionheight <= 5] <- 160
```

For the other case and for the missing data, let's use the median.

```{r}
cohort$admissionheight[cohort$admissionheight >= 250] <- NA
cohort$admissionheight <- na.aggregate(cohort$admissionheight, FUN = median)
```

Now we can plot it again and see the distribution.

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = admissionheight), fill = "darkgreen") +
labs(title = "Admission Height Distribution", x = "Height", y = "Frequency")
```

When we are preparing the data for a study we need to apply this same process to all the variables, taking into consideration the modelling strategy.

#### Admission Weight

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = admissionweight), fill = "darkblue") +
labs(title = "Admission Weight Distribution", x = "Weight", y = "Frequency")
```
#### Temperature

```{r}
ggplot(data = cohort) +
geom_histogram(aes(x = temperature), fill = "darkgreen") +
labs(title = "Admission Weight Distribution", x = "Temperature", y = "Frequency")
```

Here we see some temperatures bellow zero! Let's fix it using the median again.

```{r}
cohort$temperature[cohort$temperature <= 0] <- NA
cohort$temperature <- na.aggregate(cohort$temperature, FUN = median)

ggplot(data = cohort) +
geom_histogram(aes(x = temperature), fill = "darkgreen") +
labs(title = "Admission Weight Distribution", x = "Temperature", y = "Frequency")
```

After removing absurd data values that are very distant from the distribution we can better visualize the date, once to fit a negative temperature on the scale our plot got squeezed and difficult to see!

#### Apache Score and Acute Physiology Score

```{r}
library(gridExtra)

p1 <- ggplot(data = cohort) +
      geom_histogram(aes(x = acutephysiologyscore), fill = 'darkblue') +
      labs(title = "Acute Physiology Score Distribution", x = "Acute Physiology Score", y =   "Frequency") +
      theme(plot.title = element_text(size = 11))

p2 <- ggplot(data = cohort) +
      geom_histogram(aes(x = apachescore), fill = 'darkblue') +
      labs(title = "Apache Score Distribution", x = "Apache Score", y =   "Frequency") +
      theme(plot.title = element_text(size = 11))

grid.arrange(p1, p2, ncol = 2)
```

#### Excercise: Look at the other variables!

Hint: We can use the package `ggExtra` to plot the distributions of the variables on the axis of any graph, what we normally call "marginal distributions".

```{r}
p <- ggplot() +
      geom_point(data = cohort, aes(x = age, y = apachescore, color = gender, shape = actualhospitalmortality)) +
      geom_smooth(data = mean_apache_by_age, aes(x = age, y = apachescore, linetype = "Mean Apache Score")) +
        
      scale_shape_manual(values=c(16, 3), labels = c("Alive", "Expired"), name = 'Hospital Mortality')+
      scale_color_manual(values = c("lightcoral", "mediumseagreen", "grey"), 
                         labels = c("Female", "Male", "Unknown"), name = "Gender") +
      scale_linetype_manual(values = "solid", name = "") +
      
      xlab("Age") + 
      ylab("Apache Score") +
      ggtitle("Apache Score in the eICU demo data") +
      theme_economist() +
      theme(legend.title = element_text(size = 8, face = "bold"), 
            legend.text = element_text(size = 6),
            legend.spacing = unit(-0.1, "cm"),
            legend.key.size = unit(0.3, "cm"))
```

```{r}
install.packages("ggExtra")
library(ggExtra)

p1 <- ggMarginal(p, type="histogram") # with marginal histogram
p2 <- ggMarginal(p, type="density") # marginal density
p3 <- ggMarginal(p, type="boxplot") # marginal boxplot

p1
```

#### Mean Apache Score by Age by Gender and Actualy Mortality

```{r}
mean_apache_by_age_by_gender <- aggregate (apachescore ~ age + gender, data = cohort, FUN = mean)
mean_apache_by_age_by_mortality <- aggregate (apachescore ~ age + actualhospitalmortality, 
                                              data = cohort, FUN = mean)
```

```{r}
ggplot(mean_apache_by_age_by_gender, aes(x = age, y = apachescore, color = gender)) +
      geom_smooth() +
      ggtitle("Mean apachescore by age") +
      theme_economist()
```

```{r}
ggplot(mean_apache_by_age_by_mortality, aes(x = age, y = apachescore, color = actualhospitalmortality)) +
      geom_smooth() +
      ggtitle("Mean apachescore by age") +
      theme_economist()
```
